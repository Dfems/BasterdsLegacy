name: Deploy (Self-hosted Raspberry)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente di deploy (production)'
        required: true
        default: 'production'
      configure_apache:
        description: 'Aggiorna vhost Apache e ricarica (true/false)'
        required: true
        default: 'true'
      use_env_secret:
        description: 'Crea .env da secret ENV_PRODUCTION (true/false)'
        required: true
        default: 'false'

permissions:
  contents: read

jobs:
  deploy:
    name: Build & Deploy (Local)
    runs-on: [self-hosted, linux, raspberry]

    env:
      NODE_VERSION: '20'
      TARGET_ENV: ${{ github.event.inputs.environment || 'production' }}
      REMOTE_BASE: /home/dfems/apps/basterdslegacy
      REMOTE_FE_DIR: /var/www/basterdslegacy
      REMOTE_BE_DIR: /home/dfems/apps/basterdslegacy/server
      CONFIGURE_APACHE: ${{ github.event.inputs.configure_apache || 'true' }}
      USE_ENV_SECRET: ${{ github.event.inputs.use_env_secret || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies (root)
        run: npm ci

      - name: Build Frontend
        run: npm run build

      - name: Prepare directories
        run: |
          sudo mkdir -p "$REMOTE_FE_DIR" "$REMOTE_BE_DIR" "$REMOTE_BASE"
          sudo chown -R dfems:www-data "$REMOTE_FE_DIR"
          sudo chown -R dfems:dfems "$REMOTE_BE_DIR" "$REMOTE_BASE"
          sudo chmod -R 775 "$REMOTE_FE_DIR"

      - name: Deploy frontend assets
        run: |
          sudo rm -rf "$REMOTE_FE_DIR"/*
          sudo cp -r dist/* "$REMOTE_FE_DIR"/
          sudo chown -R www-data:www-data "$REMOTE_FE_DIR"

      - name: Sync server folder
        run: |
          rsync -az --delete --exclude node_modules --exclude dist --exclude prisma/dev.db server/ "$REMOTE_BE_DIR"/

      - name: Install server dependencies
        run: |
          cd "$REMOTE_BE_DIR"
          npm ci
          npm run build

      - name: Place environment file (.env)
        if: ${{ env.TARGET_ENV == 'production' }}
        run: |
          if [ -f "$REMOTE_BE_DIR/.env" ]; then
            echo "Existing .env found at $REMOTE_BE_DIR/.env â€” keeping it";
          elif [ "${USE_ENV_SECRET}" = "true" ] && [ -n "${{ secrets.ENV_PRODUCTION }}" ]; then
            echo "Creating .env from ENV_PRODUCTION secret";
            printf '%s' "${{ secrets.ENV_PRODUCTION }}" > "$REMOTE_BE_DIR/.env";
            sudo chown dfems:dfems "$REMOTE_BE_DIR/.env" && sudo chmod 600 "$REMOTE_BE_DIR/.env";
          elif [ -f "server/.env.production" ]; then
            echo "Copying server/.env.production to $REMOTE_BE_DIR/.env";
            cp server/.env.production "$REMOTE_BE_DIR/.env" && sudo chown dfems:dfems "$REMOTE_BE_DIR/.env" && sudo chmod 600 "$REMOTE_BE_DIR/.env";
          else
            echo "ERROR: No .env present. Provide ENV_PRODUCTION secret (and set use_env_secret=true) or create $REMOTE_BE_DIR/.env manually.";
            exit 1;
          fi

          # Ensure DATABASE_URL is present (fallback to local SQLite if missing)
          if ! grep -qE '^\s*DATABASE_URL=' "$REMOTE_BE_DIR/.env"; then
            echo 'DATABASE_URL=file:./prisma/dev.db' >> "$REMOTE_BE_DIR/.env"
            echo "Appended default DATABASE_URL to .env (file:./prisma/dev.db)"
          fi

          # Normalize line endings (remove CR if file came from Windows)
          sed -i 's/\r$//' "$REMOTE_BE_DIR/.env"

          # Normalize DATABASE_URL format (strip quotes if any)
          if grep -qE '^\s*DATABASE_URL="' "$REMOTE_BE_DIR/.env"; then
            sed -i -E 's/^\s*DATABASE_URL\s*=\s*"([^"]+)"\s*$/DATABASE_URL=\1/' "$REMOTE_BE_DIR/.env"
          fi

      - name: Prisma generate and push
        run: |
          cd "$REMOTE_BE_DIR"
          # Ensure .env is normalized (strip CR and BOM)
          sed -i 's/\r$//' .env || true
          if [ "$(head -c 3 .env | od -An -t x1 | tr -d ' \n')" = "efbbbf" ]; then
            tail -c +4 .env > .env.nobom && mv .env.nobom .env
          fi

          # Extract DATABASE_URL (handle quotes); append fallback if missing
          DB_URL=$(grep -E '^[[:space:]]*DATABASE_URL[[:space:]]*=' .env | sed -E 's/^[^=]+=//; s/^"//; s/"$//' )
          if [ -z "$DB_URL" ]; then
            DB_URL="file:./prisma/dev.db"
            echo 'DATABASE_URL=file:./prisma/dev.db' >> .env
            echo "DATABASE_URL not found in .env, using fallback: $DB_URL"
          fi

          # Ensure there is no prisma/.env to avoid conflicts
          rm -f ./prisma/.env

          npx prisma generate --schema ./prisma/schema.prisma
          npx prisma db push --schema ./prisma/schema.prisma

      - name: Ensure owner exists (non-interactive)
        env:
          OWNER_EMAIL: ${{ secrets.OWNER_EMAIL }}
          OWNER_PASSWORD: ${{ secrets.OWNER_PASSWORD }}
        run: |
          if [ -n "$OWNER_EMAIL" ] && [ -n "$OWNER_PASSWORD" ]; then
            echo "Ensuring owner user exists ($OWNER_EMAIL)"
            cd "$REMOTE_BE_DIR"
            npx tsx ./scripts/create-owner-ci.ts || true
          else
            echo "OWNER_EMAIL/OWNER_PASSWORD not set; skipping owner creation"
          fi

      - name: Install/Update systemd unit
        run: |
          sudo install -m 0644 server/deploy/basterds-server.service /etc/systemd/system/basterds-server.service
          sudo systemctl daemon-reload
          sudo systemctl enable basterds-server || true

      - name: Restart backend service
        run: sudo systemctl restart basterds-server || sudo systemctl start basterds-server

      - name: Deploy Apache vhost and reload
        if: ${{ env.CONFIGURE_APACHE == 'true' }}
        run: |
          sudo install -m 0644 server/deploy/apache-basterdslegacy.conf /etc/apache2/sites-available/basterdslegacy.conf
          sudo a2enmod ssl rewrite proxy proxy_http proxy_wstunnel headers
          sudo a2dissite basterdlegacy || true
          sudo a2dissite basterdslegacy-le-ssl || true
          sudo a2dissite 000-default default-ssl || true
          sudo a2ensite basterdslegacy || true
          sudo systemctl reload apache2

      - name: Issue/renew certificate (Certbot webroot)
        if: ${{ env.CONFIGURE_APACHE == 'true' }}
        env:
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}
        run: |
          DOMAIN=basterdslegacy.ddns.net
          sudo mkdir -p /var/www/basterdslegacy/.well-known/acme-challenge
          if [ -z "$CERTBOT_EMAIL" ]; then
            echo "CERTBOT_EMAIL non impostato; salto emissione certificato"
            exit 0
          fi
          # Richiede certbot installato sul runner; se non presente, saltare
          if command -v certbot >/dev/null 2>&1; then
            sudo certbot certonly --webroot -w /var/www/basterdslegacy -d "$DOMAIN" --agree-tos -m "$CERTBOT_EMAIL" --non-interactive --keep-until-expiring || true
            sudo systemctl reload apache2 || true
          else
            echo "certbot non installato; salto emissione certificato"
          fi

      - name: Post-deploy check
        run: |
          set -e
          for i in $(seq 1 15); do
            if curl -fsS http://localhost:3000/api/status > /dev/null; then
              echo "Health check OK"
              exit 0
            fi
            echo "Waiting for service (attempt $i)..."
            sleep 2
          done
          echo "Health check failed"
          exit 1

      - name: Diagnostics (systemd + logs)
        if: failure()
        run: |
          echo '--- systemctl status basterds-server ---'
          sudo systemctl status basterds-server --no-pager || true
          echo '--- journalctl -u basterds-server (last 200) ---'
          sudo journalctl -u basterds-server -n 200 --no-pager || true
